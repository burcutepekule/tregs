length(injury_site_updated))
if (n_pathogens_lp_new > 0) {
new_pathogen_coords = matrix(c(
sample(1:grid_size, n_pathogens_lp_new, replace = TRUE, prob = epithelium$level_injury),
rep(1, n_pathogens_lp_new),
last_id_pathogen + seq(1, n_pathogens_lp_new)
), ncol = 3)
colnames(new_pathogen_coords) = c("x", "y", "id")
pathogen_coords = rbind(pathogen_coords, new_pathogen_coords)
last_id_pathogen = last_id_pathogen + n_pathogens_lp_new
}
n_commensals_lp_new_injury = round(mean(epithelium$level_injury) * rate_leak_commensal_injury *
length(injury_site_updated))
n_commensals_lp_new_baseline = round(rate_leak_commensal_baseline * grid_size)
total_new_commensals = n_commensals_lp_new_baseline + n_commensals_lp_new_injury
if (total_new_commensals > 0) {
baseline_x = sample(1:grid_size, n_commensals_lp_new_baseline, TRUE)
injury_x = if (n_commensals_lp_new_injury > 0) {
sample(1:grid_size, n_commensals_lp_new_injury, TRUE, prob = epithelium$level_injury)
} else {
numeric(0)
}
new_commensal_coords = matrix(c(
c(baseline_x, injury_x),
rep(1, total_new_commensals),
last_id_commensal + seq(1, total_new_commensals)
), ncol = 3)
colnames(new_commensal_coords) = c("x", "y", "id")
commensal_coords = rbind(commensal_coords, new_commensal_coords)
last_id_commensal = last_id_commensal + total_new_commensals
}
# ========================================================================
# PLOTTING
# ========================================================================
if (plot_on == 1 & (t %% plot_every == 0 | t == 1)) {
source('./MISC/CONVERT_TO_DATAFRAME.R')
p = plot_simtime_simple()
ggsave(
paste0(dir_name, "/frame_seed_", seed_in, "_STERILE_", sterile, "_TREGS_",
allow_tregs, "_trnd_", randomize_tregs, "_paramset_", param_set_id_use, "_", t, ".png"),
plot = p,
width = 12,
height = 10,
dpi = 600,
bg = "white"
)
}
# ========================================================================
# UPDATE PHAGOCYTE PHENOTYPES
# ========================================================================
M0_indices = which(phagocyte_phenotype == 0)
M1_indices = which(phagocyte_phenotype == 1)
M2_indices = which(phagocyte_phenotype == 2)
# Registry shifting every digestion_time steps
if (t %% digestion_time == 0) {
phagocyte_bacteria_registry = cbind(
matrix(0, nrow = nrow(phagocyte_bacteria_registry), ncol = 1),
phagocyte_bacteria_registry[, -ncol(phagocyte_bacteria_registry)]
)
}
# Process M0 phagocytes (candidates for activation)
if (length(M0_indices) > 0) {
for (i in M0_indices) {
avg_DAMPs = get_8n_avg_signal_fast(phagocyte_x[i], phagocyte_y[i], act_radius_DAMPs, DAMPs)
avg_SAMPs = get_8n_avg_signal_fast(phagocyte_x[i], phagocyte_y[i], act_radius_SAMPs, SAMPs)
bacteria_count = sum(phagocyte_bacteria_registry[i, ])
if (avg_DAMPs >= activation_threshold_DAMPs && avg_DAMPs > avg_SAMPs) {
phagocyte_phenotype[i] = 1
phagocyte_active_age[i] = 1
phagocyte_activity_ROS[i] = activity_ROS_M1_baseline + activity_ROS_M1_step * bacteria_count
phagocyte_activity_engulf[i] = activity_engulf_M1_baseline + activity_engulf_M1_step * bacteria_count
} else if (avg_SAMPs >= activation_threshold_SAMPs && avg_SAMPs > avg_DAMPs) {
phagocyte_phenotype[i] = 2
phagocyte_active_age[i] = 1
phagocyte_activity_ROS[i] = activity_ROS_M2_baseline
phagocyte_activity_engulf[i] = activity_engulf_M2_baseline + activity_engulf_M2_step * bacteria_count
}
}
}
# Process M1/M2 phagocytes
active_indices = c(M1_indices, M2_indices)
if (length(active_indices) > 0) {
phagocyte_active_age[active_indices] = phagocyte_active_age[active_indices] + 1
old_enough = phagocyte_active_age[active_indices] >= active_age_limit
candidates = active_indices[old_enough]
for (i in candidates) {
avg_DAMPs = get_8n_avg_signal_fast(phagocyte_x[i], phagocyte_y[i], act_radius_DAMPs, DAMPs)
avg_SAMPs = get_8n_avg_signal_fast(phagocyte_x[i], phagocyte_y[i], act_radius_SAMPs, SAMPs)
bacteria_count = sum(phagocyte_bacteria_registry[i, ])
if (avg_DAMPs >= activation_threshold_DAMPs && avg_DAMPs > avg_SAMPs) {
phagocyte_phenotype[i] = 1
phagocyte_active_age[i] = 1
phagocyte_activity_ROS[i] = activity_ROS_M1_baseline + activity_ROS_M1_step * bacteria_count
phagocyte_activity_engulf[i] = activity_engulf_M1_baseline + activity_engulf_M1_step * bacteria_count
} else if (avg_SAMPs >= activation_threshold_SAMPs && avg_SAMPs > avg_DAMPs) {
phagocyte_phenotype[i] = 2
phagocyte_active_age[i] = 1
phagocyte_activity_ROS[i] = activity_ROS_M2_baseline
phagocyte_activity_engulf[i] = activity_engulf_M2_baseline + activity_engulf_M2_step * bacteria_count
} else if (avg_SAMPs < activation_threshold_SAMPs && avg_DAMPs < activation_threshold_DAMPs) {
phagocyte_phenotype[i] = 0
phagocyte_active_age[i] = 0
phagocyte_activity_ROS[i] = activity_ROS_M0_baseline
phagocyte_activity_engulf[i] = activity_engulf_M0_baseline
}
}
}
# ========================================================================
# UPDATE TREG ACTIVE AGE
# ========================================================================
active_treg_indices = which(treg_phenotype == 1)
if (length(active_treg_indices) > 0) {
old_tregs = active_treg_indices[treg_active_age[active_treg_indices] >= active_age_limit]
young_tregs = active_treg_indices[treg_active_age[active_treg_indices] < active_age_limit]
if (length(young_tregs) > 0) {
treg_active_age[young_tregs] = treg_active_age[young_tregs] + 1
}
if (length(old_tregs) > 0) {
treg_phenotype[old_tregs] = 0
treg_active_age[old_tregs] = 0
treg_activity_SAMPs_binary[old_tregs] = 0
}
}
# ========================================================================
# ENGULFMENT PROCESS
# ========================================================================
phagocyte_positions = paste(phagocyte_x, phagocyte_y, sep = "_")
for (i in 1:length(phagocyte_x)) {
px = phagocyte_x[i]
py = phagocyte_y[i]
# Pathogen engulfment
if (nrow(pathogen_coords) > 0) {
pathogen_overlap = (pathogen_coords[, "x"] == px) & (pathogen_coords[, "y"] == py)
pathogen_indices = which(pathogen_overlap)
if (length(pathogen_indices) > 0) {
engulf_success = runif(length(pathogen_indices)) < phagocyte_activity_engulf[i]
indices_to_engulf = pathogen_indices[engulf_success]
if (length(indices_to_engulf) > 0) {
phagocyte_pathogens_engulfed[i] = phagocyte_pathogens_engulfed[i] + length(indices_to_engulf)
pathogen_coords = pathogen_coords[-indices_to_engulf, , drop = FALSE]
phagocyte_bacteria_registry[i, ] = shift_insert_fast(
phagocyte_bacteria_registry[i, ],
rep(1, length(indices_to_engulf))
)
phagocyte_phenotype_index = phagocyte_phenotype[i] + 1
pathogens_killed_by_Mac[phagocyte_phenotype_index] =
pathogens_killed_by_Mac[phagocyte_phenotype_index] + length(indices_to_engulf)
}
}
}
# Commensal engulfment
if (nrow(commensal_coords) > 0) {
commensal_overlap = (commensal_coords[, "x"] == px) & (commensal_coords[, "y"] == py)
commensal_indices = which(commensal_overlap)
if (length(commensal_indices) > 0) {
engulf_success = runif(length(commensal_indices)) < phagocyte_activity_engulf[i]
indices_to_engulf = commensal_indices[engulf_success]
if (length(indices_to_engulf) > 0) {
phagocyte_commensals_engulfed[i] = phagocyte_commensals_engulfed[i] + length(indices_to_engulf)
commensal_coords = commensal_coords[-indices_to_engulf, , drop = FALSE]
phagocyte_bacteria_registry[i, ] = shift_insert_fast(
phagocyte_bacteria_registry[i, ],
rep(1, length(indices_to_engulf))
)
phagocyte_phenotype_index = phagocyte_phenotype[i] + 1
commensals_killed_by_Mac[phagocyte_phenotype_index] =
commensals_killed_by_Mac[phagocyte_phenotype_index] + length(indices_to_engulf)
}
}
}
}
# ========================================================================
# TREG ACTIVATION & EFFECTOR ACTIONS (UPDATED: Beta distribution sampling)
# CRITICAL: Always consume random numbers to maintain stream synchronization!
# ========================================================================
M1_phagocyte_indices = which(phagocyte_phenotype == 1)
if (length(M1_phagocyte_indices) > 0) {
for (i in M1_phagocyte_indices) {
px = phagocyte_x[i]
py = phagocyte_y[i]
treg_distances_x = abs(treg_x - px)
treg_distances_y = abs(treg_y - py)
nearby_treg_indices = which(treg_distances_x <= treg_vicinity_effect &
treg_distances_y <= treg_vicinity_effect)
if (length(nearby_treg_indices) > 0) {
num_pat_antigens = phagocyte_pathogens_engulfed[i]
num_com_antigens = phagocyte_commensals_engulfed[i]
if ((num_pat_antigens + num_com_antigens) > 0) {
# ALWAYS calculate and sample (to maintain stream synchronization)
rat_com_pat_real = num_com_antigens / (num_com_antigens + num_pat_antigens)
alpha = (1 - treg_discrimination_efficiency) * 1 +
treg_discrimination_efficiency * (rat_com_pat_real * precision)
beta = (1 - treg_discrimination_efficiency) * 1 +
treg_discrimination_efficiency * ((1 - rat_com_pat_real) * precision)
# ALWAYS consume from random stream (both Tregs ON and OFF)
rat_com_pat = sample_rbeta(alpha, beta)
# But ONLY apply the effect if Tregs are allowed to work
if (allow_tregs_to_do_their_job && rat_com_pat > rat_com_pat_threshold) {
treg_phenotype[nearby_treg_indices] = 1
treg_activity_SAMPs_binary[nearby_treg_indices] = 1
treg_active_age[nearby_treg_indices] = 1
if (allow_tregs_to_suppress_cognate) {
phagocyte_phenotype[i] = 2
phagocyte_active_age[i] = 1
bacteria_count = sum(phagocyte_bacteria_registry[i, ])
phagocyte_activity_ROS[i] = activity_ROS_M2_baseline
phagocyte_activity_engulf[i] = activity_engulf_M2_baseline +
activity_engulf_M2_step * bacteria_count
}
}
}
}
}
}
# ========================================================================
# KILL MICROBES WITH ROS
# ========================================================================
if (nrow(pathogen_coords) > 0) {
pathogen_avg_ROS = numeric(nrow(pathogen_coords))
for (i in 1:nrow(pathogen_coords)) {
pathogen_avg_ROS[i] = get_8n_avg_signal_fast(
pathogen_coords[i, "x"],
pathogen_coords[i, "y"],
act_radius_ROS, ROS
)
}
pathogens_to_kill = which(pathogen_avg_ROS > th_ROS_microbe)
if (length(pathogens_to_kill) > 0) {
pathogen_coords = pathogen_coords[-pathogens_to_kill, , drop = FALSE]
pathogens_killed_by_ROS = pathogens_killed_by_ROS + length(pathogens_to_kill)
}
}
if (nrow(commensal_coords) > 0) {
commensal_avg_ROS = numeric(nrow(commensal_coords))
for (i in 1:nrow(commensal_coords)) {
commensal_avg_ROS[i] = get_8n_avg_signal_fast(
commensal_coords[i, "x"],
commensal_coords[i, "y"],
act_radius_ROS, ROS
)
}
commensals_to_kill = which(commensal_avg_ROS > th_ROS_microbe)
if (length(commensals_to_kill) > 0) {
commensal_coords = commensal_coords[-commensals_to_kill, , drop = FALSE]
commensals_killed_by_ROS = commensals_killed_by_ROS + length(commensals_to_kill)
}
}
# ========================================================================
# UPDATE EPITHELIAL INJURY (UPDATED: only pathogens, logistic function)
# ========================================================================
for (i in 1:nrow(epithelium)) {
px = epithelium$x[i]
# Get ROS values in vicinity
x_coordinates = pmax(1, pmin(grid_size, (px - act_radius_ROS):(px + act_radius_ROS)))
ros_values = ROS[1, x_coordinates]
mean_ros = mean(ros_values)
# UPDATED: Increase level_injury based on pathogen count ONLY (using logistic function)
count_pathogens = pathogen_epithelium_counts[px]
epithelium$level_injury[i] = epithelium$level_injury[i] +
logistic_scaled_0_to_5_quantized(count_pathogens)
# NOTE: Commensals NO LONGER contribute to epithelial injury (removed from STANDALONE)
# Increase level_injury based on ROS
if (mean_ros > th_ROS_epith_recover) {
epithelium$level_injury[i] = epithelium$level_injury[i] + 1
}
# Apply maximum injury constraint
epithelium$level_injury[i] = min(epithelium$level_injury[i], max_level_injury)
# RECOVERY: Stochastic recovery when injured
if (epithelium$level_injury[i] > 0 && runif(1) < epith_recovery_chance) {
epithelium$level_injury[i] = max(0, epithelium$level_injury[i] - 1)
}
}
# ========================================================================
# SAVE ABUNDANCES
# ========================================================================
epithelium_longitudinal[t, ] = as.numeric(table(factor(epithelium$level_injury, levels = 0:5)))
phagocyte_counts = c(
sum(phagocyte_phenotype == 0),
tabulate(phagocyte_active_age[phagocyte_phenotype == 1] + 1, cc_phagocyte + 1),
tabulate(phagocyte_active_age[phagocyte_phenotype == 2] + 1, cc_phagocyte + 1)
)
macrophages_longitudinal[t, ] = phagocyte_counts
microbes_longitudinal[t, ] = c(nrow(commensal_coords), nrow(pathogen_coords))
tregs_longitudinal[t, ] = c(sum(treg_phenotype == 0), sum(treg_phenotype == 1))
microbes_cumdeath_longitudinal[t, ] = c(
commensals_killed_by_ROS, commensals_killed_by_Mac,
pathogens_killed_by_ROS, pathogens_killed_by_Mac
)
}
#!/usr/bin/env Rscript
# Generate synchronized random number stream for reproducible scenario comparisons
# This ensures Tregs ON vs OFF comparisons use identical random events
rm(list=ls())
library(dplyr)
library(tidyr)
# # Set parameters
# n_simulations <- 100  # How many full simulations to support
# t_max <- 500          # Timesteps per simulation
# safety_factor <- 10   # Multiply by this to ensure enough random numbers
#
# # Estimate random draws per timestep (conservative upper bound)
# grid_size <- 25
# n_agents <- round(grid_size^2 * 0.35) * 2  # phagocytes + tregs
# n_microbes_max <- 500  # conservative max
#
# draws_per_timestep <- (
#   n_agents * 2 +           # agent movement (2 draws per agent for dx, dy)
#   n_microbes_max * 2 +     # microbe movement
#   n_microbes_max * 2 +     # ROS killing checks
#   n_agents * 10 +          # engulfment, activation, etc
#   grid_size * 2 +          # epithelial injury/recovery
#   100                      # buffer for misc operations
# )
#
# total_draws_needed <- n_simulations * t_max * draws_per_timestep * safety_factor
total_draws_needed = 1e7
# cat(sprintf("Generating %d random numbers...\n", total_draws_needed))
# cat(sprintf("  This supports ~%d simulations of %d timesteps\n", n_simulations, t_max))
# Generate random numbers using R's high-quality RNG
int_in = 0
set.seed(int_in)  # For reproducibility of the stream itself
random_stream <- runif(total_draws_needed)
# Convert to data frame
random_df <- data.frame(random_number = random_stream)
# Save to file
output_file = paste0("random_numbers_seed_",int_in,".csv")
write_csv(random_df, file = output_file)
cat(sprintf("\nRandom number stream saved to: %s\n", output_file))
cat(sprintf("File size: %.2f MB\n", file.info(output_file)$size / 1e6))
cat("\nUsage:\n")
cat("  - All simulations will draw from this stream sequentially\n")
cat("  - Reset the stream index before each new simulation\n")
cat("  - This ensures Tregs ON vs OFF use IDENTICAL random events\n")
#!/usr/bin/env Rscript
# Generate synchronized random number stream for reproducible scenario comparisons
# This ensures Tregs ON vs OFF comparisons use identical random events
rm(list=ls())
library(dplyr)
library(tidyr)
# # Set parameters
# n_simulations <- 100  # How many full simulations to support
# t_max <- 500          # Timesteps per simulation
# safety_factor <- 10   # Multiply by this to ensure enough random numbers
#
# # Estimate random draws per timestep (conservative upper bound)
# grid_size <- 25
# n_agents <- round(grid_size^2 * 0.35) * 2  # phagocytes + tregs
# n_microbes_max <- 500  # conservative max
#
# draws_per_timestep <- (
#   n_agents * 2 +           # agent movement (2 draws per agent for dx, dy)
#   n_microbes_max * 2 +     # microbe movement
#   n_microbes_max * 2 +     # ROS killing checks
#   n_agents * 10 +          # engulfment, activation, etc
#   grid_size * 2 +          # epithelial injury/recovery
#   100                      # buffer for misc operations
# )
#
# total_draws_needed <- n_simulations * t_max * draws_per_timestep * safety_factor
total_draws_needed = 1e7
# cat(sprintf("Generating %d random numbers...\n", total_draws_needed))
# cat(sprintf("  This supports ~%d simulations of %d timesteps\n", n_simulations, t_max))
# Generate random numbers using R's high-quality RNG
int_in = 1
set.seed(int_in)  # For reproducibility of the stream itself
random_stream <- runif(total_draws_needed)
# Convert to data frame
random_df <- data.frame(random_number = random_stream)
# Save to file
output_file = paste0("random_numbers_seed_",int_in,".csv")
write_csv(random_df, file = output_file)
cat(sprintf("\nRandom number stream saved to: %s\n", output_file))
cat(sprintf("File size: %.2f MB\n", file.info(output_file)$size / 1e6))
cat("\nUsage:\n")
cat("  - All simulations will draw from this stream sequentially\n")
cat("  - Reset the stream index before each new simulation\n")
cat("  - This ensures Tregs ON vs OFF use IDENTICAL random events\n")
#!/usr/bin/env Rscript
# Generate synchronized random number stream for reproducible scenario comparisons
# This ensures Tregs ON vs OFF comparisons use identical random events
rm(list=ls())
library(dplyr)
library(tidyr)
# # Set parameters
# n_simulations <- 100  # How many full simulations to support
# t_max <- 500          # Timesteps per simulation
# safety_factor <- 10   # Multiply by this to ensure enough random numbers
#
# # Estimate random draws per timestep (conservative upper bound)
# grid_size <- 25
# n_agents <- round(grid_size^2 * 0.35) * 2  # phagocytes + tregs
# n_microbes_max <- 500  # conservative max
#
# draws_per_timestep <- (
#   n_agents * 2 +           # agent movement (2 draws per agent for dx, dy)
#   n_microbes_max * 2 +     # microbe movement
#   n_microbes_max * 2 +     # ROS killing checks
#   n_agents * 10 +          # engulfment, activation, etc
#   grid_size * 2 +          # epithelial injury/recovery
#   100                      # buffer for misc operations
# )
#
# total_draws_needed <- n_simulations * t_max * draws_per_timestep * safety_factor
total_draws_needed = 1e7
# cat(sprintf("Generating %d random numbers...\n", total_draws_needed))
# cat(sprintf("  This supports ~%d simulations of %d timesteps\n", n_simulations, t_max))
# Generate random numbers using R's high-quality RNG
int_in = 2
set.seed(int_in)  # For reproducibility of the stream itself
random_stream <- runif(total_draws_needed)
# Convert to data frame
random_df <- data.frame(random_number = random_stream)
# Save to file
output_file = paste0("random_numbers_seed_",int_in,".csv")
write_csv(random_df, file = output_file)
cat(sprintf("\nRandom number stream saved to: %s\n", output_file))
cat(sprintf("File size: %.2f MB\n", file.info(output_file)$size / 1e6))
cat("\nUsage:\n")
cat("  - All simulations will draw from this stream sequentially\n")
cat("  - Reset the stream index before each new simulation\n")
cat("  - This ensures Tregs ON vs OFF use IDENTICAL random events\n")
#!/usr/bin/env Rscript
# Generate synchronized random number stream for reproducible scenario comparisons
# This ensures Tregs ON vs OFF comparisons use identical random events
rm(list=ls())
library(dplyr)
library(tidyr)
# # Set parameters
# n_simulations <- 100  # How many full simulations to support
# t_max <- 500          # Timesteps per simulation
# safety_factor <- 10   # Multiply by this to ensure enough random numbers
#
# # Estimate random draws per timestep (conservative upper bound)
# grid_size <- 25
# n_agents <- round(grid_size^2 * 0.35) * 2  # phagocytes + tregs
# n_microbes_max <- 500  # conservative max
#
# draws_per_timestep <- (
#   n_agents * 2 +           # agent movement (2 draws per agent for dx, dy)
#   n_microbes_max * 2 +     # microbe movement
#   n_microbes_max * 2 +     # ROS killing checks
#   n_agents * 10 +          # engulfment, activation, etc
#   grid_size * 2 +          # epithelial injury/recovery
#   100                      # buffer for misc operations
# )
#
# total_draws_needed <- n_simulations * t_max * draws_per_timestep * safety_factor
total_draws_needed = 1e7
# cat(sprintf("Generating %d random numbers...\n", total_draws_needed))
# cat(sprintf("  This supports ~%d simulations of %d timesteps\n", n_simulations, t_max))
# Generate random numbers using R's high-quality RNG
int_in = 3
set.seed(int_in)  # For reproducibility of the stream itself
random_stream <- runif(total_draws_needed)
# Convert to data frame
random_df <- data.frame(random_number = random_stream)
# Save to file
output_file = paste0("random_numbers_seed_",int_in,".csv")
write_csv(random_df, file = output_file)
cat(sprintf("\nRandom number stream saved to: %s\n", output_file))
cat(sprintf("File size: %.2f MB\n", file.info(output_file)$size / 1e6))
cat("\nUsage:\n")
cat("  - All simulations will draw from this stream sequentially\n")
cat("  - Reset the stream index before each new simulation\n")
cat("  - This ensures Tregs ON vs OFF use IDENTICAL random events\n")
#!/usr/bin/env Rscript
# Generate synchronized random number stream for reproducible scenario comparisons
# This ensures Tregs ON vs OFF comparisons use identical random events
rm(list=ls())
library(dplyr)
library(tidyr)
# # Set parameters
# n_simulations <- 100  # How many full simulations to support
# t_max <- 500          # Timesteps per simulation
# safety_factor <- 10   # Multiply by this to ensure enough random numbers
#
# # Estimate random draws per timestep (conservative upper bound)
# grid_size <- 25
# n_agents <- round(grid_size^2 * 0.35) * 2  # phagocytes + tregs
# n_microbes_max <- 500  # conservative max
#
# draws_per_timestep <- (
#   n_agents * 2 +           # agent movement (2 draws per agent for dx, dy)
#   n_microbes_max * 2 +     # microbe movement
#   n_microbes_max * 2 +     # ROS killing checks
#   n_agents * 10 +          # engulfment, activation, etc
#   grid_size * 2 +          # epithelial injury/recovery
#   100                      # buffer for misc operations
# )
#
# total_draws_needed <- n_simulations * t_max * draws_per_timestep * safety_factor
total_draws_needed = 1e7
# cat(sprintf("Generating %d random numbers...\n", total_draws_needed))
# cat(sprintf("  This supports ~%d simulations of %d timesteps\n", n_simulations, t_max))
# Generate random numbers using R's high-quality RNG
for (int_in in 0:100){
set.seed(int_in)  # For reproducibility of the stream itself
random_stream <- runif(total_draws_needed)
# Convert to data frame
random_df <- data.frame(random_number = random_stream)
# Save to file
output_file = paste0("random_numbers_seed_",int_in,".csv")
write_csv(random_df, file = output_file)
cat(sprintf("\nRandom number stream saved to: %s\n", output_file))
cat(sprintf("File size: %.2f MB\n", file.info(output_file)$size / 1e6))
cat("\nUsage:\n")
cat("  - All simulations will draw from this stream sequentially\n")
cat("  - Reset the stream index before each new simulation\n")
cat("  - This ensures Tregs ON vs OFF use IDENTICAL random events\n")
}
dir_name = './frames'
dir.create(dir_name, showWarnings = FALSE)
